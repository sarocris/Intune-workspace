#region initialize
# Enable TLS 1.2 support 
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# ===================== WORKSPACE CONFIG =====================
# Replace with your Log Analytics Workspace ID
$CustomerId = "<YOUR_WORKSPACE_ID>"  

# Replace with your Primary Key
$SharedKey  = "<YOUR_PRIMARY_KEY>"

# Control if you want to collect App or Device Inventory or both (True = Collect)
$CollectAppInventory    = $true
$CollectDeviceInventory = $true

# Log types (tables will be AppInventory_CL and DeviceInventory_CL)
$AppLogName    = "AppInventory"
$DeviceLogName = "DeviceInventory"

# Batch size for App inventory (tested stable with 10)
$AppBatchSize = 10

$Date = (Get-Date)

# Time field used by LA – we’ll stamp TimeGenerated on each record
$TimeStampField = "TimeGenerated"
#endregion initialize


#region functions from LA-big + batching
function Get-AzureADTenantID {
    $AzureADTenantInfoRegistryKeyPath = "HKLM:\SYSTEM\CurrentControlSet\Control\CloudDomainJoin\TenantInfo"
    $AzureADTenantID = Get-ChildItem -Path $AzureADTenantInfoRegistryKeyPath | Select-Object -ExpandProperty "PSChildName"
    return $AzureADTenantID
}

function Get-AzureADDeviceID {
    Process {
        $AzureADJoinInfoRegistryKeyPath = "HKLM:\SYSTEM\CurrentControlSet\Control\CloudDomainJoin\JoinInfo"
        $AzureADJoinInfoThumbprint = Get-ChildItem -Path $AzureADJoinInfoRegistryKeyPath | Select-Object -ExpandProperty "PSChildName"
        if ($AzureADJoinInfoThumbprint -ne $null) {
            $AzureADJoinCertificate = Get-ChildItem -Path "Cert:\LocalMachine\My" -Recurse | Where-Object { $PSItem.Thumbprint -eq $AzureADJoinInfoThumbprint }
            if ($AzureADJoinCertificate -ne $null) {
                $AzureADDeviceID = ($AzureADJoinCertificate | Select-Object -ExpandProperty "Subject") -replace "CN=", ""
                return $AzureADDeviceID
            }
        }
    }
}

function Get-AzureADJoinDate {
    Process {
        $AzureADJoinInfoRegistryKeyPath = "HKLM:\SYSTEM\CurrentControlSet\Control\CloudDomainJoin\JoinInfo"
        $AzureADJoinInfoThumbprint = Get-ChildItem -Path $AzureADJoinInfoRegistryKeyPath | Select-Object -ExpandProperty "PSChildName"
        if ($AzureADJoinInfoThumbprint -ne $null) {
            $AzureADJoinCertificate = Get-ChildItem -Path "Cert:\LocalMachine\My" -Recurse | Where-Object { $PSItem.Thumbprint -eq $AzureADJoinInfoThumbprint }
            if ($AzureADJoinCertificate -ne $null) {
                $AzureADJoinDate = ($AzureADJoinCertificate | Select-Object -ExpandProperty "NotBefore") 
                return $AzureADJoinDate
            }
        }
    }
}

function Get-InstalledApplications {
    param(
        [string]$UserSid
    )
    
    New-PSDrive -PSProvider Registry -Name "HKU" -Root HKEY_USERS | Out-Null
    $regpath = @("HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*")
    if ($UserSid) {
        $regpath += "HKU:\$UserSid\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
    }
    if (-not ([IntPtr]::Size -eq 4)) {
        $regpath += "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
        if ($UserSid) {
            $regpath += "HKU:\$UserSid\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
        }
    }

    $propertyNames = 'DisplayName', 'DisplayVersion', 'Publisher', 'UninstallString', 'InstallLocation', 'InstallDate', 'InstallSource'
    $Apps = Get-ItemProperty $regpath -Name $propertyNames -ErrorAction SilentlyContinue |
        ForEach-Object { if ($_.DisplayName) { $_ } } |
        Select-Object DisplayName, DisplayVersion, Publisher, UninstallString, PSPath, InstallLocation, InstallDate, InstallSource |
        Sort-Object DisplayName   

    Remove-PSDrive -Name "HKU" | Out-Null
    return $Apps
}

# Core sender reused from LA-big, but used in batched mode
Function Send-LogAnalyticsData {
    param(
        [string]$sharedKey,
        [byte[]]$body, 
        [string]$logType,
        [string]$customerId
    )

    $method      = "POST"
    $contentType = "application/json"
    $resource    = "/api/logs"
    $date        = [DateTime]::UtcNow.ToString("r")
    $contentLength = $body.Length

    # 32 MB check
    if ($body.Length -gt (31.9 * 1024 * 1024)) {
        throw("Upload payload is too big and exceed the 32Mb limit for a single upload. Current payload size is: " + ($body.Length/1024/1024).ToString("#.#") + "Mb")
    }
    $payloadsize = ("Upload payload size is " + ($body.Length/1024).ToString("#.#") + "Kb ")

    $xHeaders     = "x-ms-date:" + $date
    $stringToHash = $method + "`n" + $contentLength + "`n" + $contentType + "`n" + $xHeaders + "`n" + $resource
    $bytesToHash  = [Text.Encoding]::UTF8.GetBytes($stringToHash)
    $keyBytes     = [Convert]::FromBase64String($sharedKey)

    $sha256    = New-Object System.Security.Cryptography.HMACSHA256
    $sha256.Key = $keyBytes
    $calculatedHash = $sha256.ComputeHash($bytesToHash)
    $encodedHash    = [Convert]::ToBase64String($calculatedHash)
    $signature      = 'SharedKey {0}:{1}' -f $customerId, $encodedHash

    $uri = "https://$customerId.ods.opinsights.azure.com$resource?api-version=2016-04-01"

    $headers = @{
        "Authorization"        = $signature;
        "Log-Type"             = $logType;
        "x-ms-date"            = $date;
        "time-generated-field" = $TimeStampField;
    }

    try {
        $response = Invoke-WebRequest -Uri $uri -Method $method -ContentType $contentType -Headers $headers -Body $body -UseBasicParsing
        $statusmessage = "$($response.StatusCode) : $($payloadsize)"
    }
    catch {
        if ($_.Exception.Response) {
            $stream   = $_.Exception.Response.GetResponseStream()
            $reader   = New-Object System.IO.StreamReader($stream)
            $respBody = $reader.ReadToEnd()
            $statusmessage = "ERROR : $payloadsize : $($respBody)"
        }
        else {
            $statusmessage = "ERROR : $payloadsize : $($_.Exception.Message)"
        }
    }

    return $statusmessage 
}

# Helper: send an array of records as one batch
function Send-BatchToLogAnalytics {
    param(
        [array]$Records,
        [string]$LogType,
        [string]$CustomerId,
        [string]$SharedKey
    )

    if (-not $Records -or $Records.Count -eq 0) {
        return $null
    }

    $json  = $Records | ConvertTo-Json -Depth 5
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($json)
    $resp  = Send-LogAnalyticsData -customerId $CustomerId -sharedKey $SharedKey -body $bytes -logType $LogType
    return $resp
}
#endregion functions


#region script – common device info (from LA-big)
# Get Intune DeviceID and ManagedDeviceName
if (@(Get-ChildItem HKLM:SOFTWARE\Microsoft\Enrollments\ -Recurse | Where-Object { $_.PSChildName -eq 'MS DM Server' })) {
    $MSDMServerInfo = Get-ChildItem HKLM:SOFTWARE\Microsoft\Enrollments\ -Recurse | Where-Object { $_.PSChildName -eq 'MS DM Server' }
    $ManagedDeviceInfo = Get-ItemProperty -LiteralPath "Registry::$($MSDMServerInfo)"
}

$ManagedDeviceName = $ManagedDeviceInfo.EntDeviceName
$ManagedDeviceID   = $ManagedDeviceInfo.EntDMID
$AzureADDeviceID   = Get-AzureADDeviceID
$AzureADTenantID   = Get-AzureADTenantID

# Computer Info
$ComputerInfo          = Get-CimInstance -ClassName Win32_ComputerSystem
$ComputerName          = $ComputerInfo.Name
$ComputerManufacturer  = $ComputerInfo.Manufacturer

if ($ComputerManufacturer -match "HP|Hewlett-Packard") {
    $ComputerManufacturer = "HP"
}

#endregion common


#region DEVICEINVENTORY (rich, from LA-big)
$DevicePayLoad = $null
if ($CollectDeviceInventory) {
    # Windows Update settings
    $DefaultAUService = (New-Object -ComObject "Microsoft.Update.ServiceManager").Services | Where-Object { $_.isDefaultAUService -eq $True } | Select-Object Name
    $AUMeteredNetwork = (Get-ItemProperty -Path HKLM:\Software\Microsoft\WindowsUpdate\UX\Settings\).AllowAutoWindowsUpdateDownloadOverMeteredNetwork 
    if ($AUMeteredNetwork -eq "0") { $AUMetered = "false" } else { $AUMetered = "true" }

    # Computer inventory
    $ComputerOSInfo   = Get-CimInstance -ClassName Win32_OperatingSystem
    $ComputerBiosInfo = Get-CimInstance -ClassName Win32_Bios
    $ComputerModel    = $ComputerInfo.Model
    $ComputerLastBoot = $ComputerOSInfo.LastBootUpTime
    $ComputerUptime   = [int](New-TimeSpan -Start $ComputerLastBoot -End $Date).Days
    $ComputerInstallDate = $ComputerOSInfo.InstallDate

    $DisplayVersion = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name DisplayVersion -ErrorAction SilentlyContinue).DisplayVersion
    if ([string]::IsNullOrEmpty($DisplayVersion)) {
        $ComputerWindowsVersion = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name ReleaseId).ReleaseId
    } else {
        $ComputerWindowsVersion = $DisplayVersion
    }

    $ComputerOSName        = $ComputerOSInfo.Caption
    $ComputerSystemSkuNumber = $ComputerInfo.SystemSKUNumber
    $ComputerSerialNr      = $ComputerBiosInfo.SerialNumber
    $ComputerBiosUUID      = Get-CimInstance Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID
    $ComputerBiosVersion   = $ComputerBiosInfo.SMBIOSBIOSVersion
    $ComputerBiosDate      = $ComputerBiosInfo.ReleaseDate
    $ComputerFirmwareType  = $env:firmware_type
    $PCSystemType          = $ComputerInfo.PCSystemType
    switch ($PCSystemType) {
        0 {$ComputerPCSystemType = "Unspecified"}
        1 {$ComputerPCSystemType = "Desktop"}
        2 {$ComputerPCSystemType = "Laptop"}
        3 {$ComputerPCSystemType = "Workstation"}
        4 {$ComputerPCSystemType = "EnterpriseServer"}
        5 {$ComputerPCSystemType = "SOHOServer"}
        6 {$ComputerPCSystemType = "AppliancePC"}
        7 {$ComputerPCSystemType = "PerformanceServer"}
        8 {$ComputerPCSystemType = "Maximum"}
        default {$ComputerPCSystemType = "Unspecified"}
    }

    $PCSystemTypeEx = $ComputerInfo.PCSystemTypeEx
    switch ($PCSystemTypeEx) {
        0 {$ComputerPCSystemTypeEx = "Unspecified"}
        1 {$ComputerPCSystemTypeEx = "Desktop"}
        2 {$ComputerPCSystemTypeEx = "Laptop"}
        3 {$ComputerPCSystemTypeEx = "Workstation"}
        4 {$ComputerPCSystemTypeEx = "EnterpriseServer"}
        5 {$ComputerPCSystemTypeEx = "SOHOServer"}
        6 {$ComputerPCSystemTypeEx = "AppliancePC"}
        7 {$ComputerPCSystemTypeEx = "PerformanceServer"}
        8 {$ComputerPCSystemTypeEx = "Slate"}
        9 {$ComputerPCSystemTypeEx = "Maximum"}
        default {$ComputerPCSystemTypeEx = "Unspecified"}
    }

    $ComputerPhysicalMemory = [Math]::Round(($ComputerInfo.TotalPhysicalMemory / 1GB))
    $ComputerOSBuild        = $ComputerOSInfo.BuildNumber
    $ComputerOSRevision     = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion' -Name UBR).UBR
    $ComputerCPU            = Get-CimInstance win32_processor | Select-Object Name, Manufacturer, NumberOfCores, NumberOfLogicalProcessors
    $ComputerProcessorManufacturer = $ComputerCPU.Manufacturer | Get-Unique
    $ComputerProcessorName        = $ComputerCPU.Name | Get-Unique
    $ComputerNumberOfCores        = $ComputerCPU.NumberOfCores | Get-Unique
    $ComputerNumberOfLogicalProcessors = $ComputerCPU.NumberOfLogicalProcessors | Get-Unique
    $ComputerSystemSKU            = (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).SystemSku.Trim()

    try {
        $TPMValues = Get-Tpm -ErrorAction SilentlyContinue | Select-Object -Property TPMReady, TPMPresent, TPMEnabled, TPMActivated, ManagedAuthLevel
    } catch { $TPMValues = $null }

    try {
        $ComputerTPMThumbprint = (Get-TpmEndorsementKeyInfo).AdditionalCertificates.Thumbprint
    } catch { $ComputerTPMThumbprint = $null }

    try {
        $BitLockerInfo = Get-BitLockerVolume -MountPoint $env:SystemDrive | Select-Object -Property *
    } catch { $BitLockerInfo = $null }

    $ComputerTPMReady    = $TPMValues.TPMReady
    $ComputerTPMPresent  = $TPMValues.TPMPresent
    $ComputerTPMEnabled  = $TPMValues.TPMEnabled
    $ComputerTPMActivated= $TPMValues.TPMActivated

    $ComputerBitlockerCipher          = $BitLockerInfo.EncryptionMethod
    $ComputerBitlockerStatus          = $BitLockerInfo.VolumeStatus
    $ComputerBitlockerProtection      = $BitLockerInfo.ProtectionStatus
    $ComputerDefaultAUService         = $DefaultAUService.Name
    $ComputerAUMetered                = $AUMetered

    # Manufacturer-specific tweaks
    switch -Wildcard ($ComputerManufacturer) {
        "*Microsoft*" {
            $ComputerManufacturer = "Microsoft"
            $ComputerModel = (Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model).Trim()
            $ComputerSystemSKU = Get-WmiObject -Namespace root\wmi -Class MS_SystemInformation | Select-Object -ExpandProperty SystemSKU
        }
        "*HP*" {
            $ComputerModel    = (Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model).Trim()
            $ComputerSystemSKU= (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).BaseBoardProduct.Trim()
            $CurrentBIOSProperties = (Get-WmiObject -Class Win32_BIOS | Select-Object -Property *)
            switch -wildcard ($($CurrentBIOSProperties.SMBIOSBIOSVersion)) {
                "*ver*" {
                    if ($CurrentBIOSProperties.SMBIOSBIOSVersion -match '.F.\d+$') {
                        $ComputerBiosVersion = ($CurrentBIOSProperties.SMBIOSBIOSVersion -split "Ver.")[1].Trim()
                    } else {
                        $ComputerBiosVersion = [System.Version]::Parse(($CurrentBIOSProperties.SMBIOSBIOSVersion).TrimStart($CurrentBIOSProperties.SMBIOSBIOSVersion.Split(".")[0]).TrimStart(".").Trim().Split(" ")[0])
                    }
                }
                default {
                    $ComputerBiosVersion = "$($CurrentBIOSProperties.SystemBiosMajorVersion).$($CurrentBIOSProperties.SystemBiosMinorVersion)"
                }
            }
        }
        "*Dell*" {
            $ComputerManufacturer = "Dell"
            $ComputerModel    = (Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model).Trim()
            $ComputerSystemSKU= (Get-CIMInstance -ClassName MS_SystemInformation -NameSpace root\WMI).SystemSku.Trim()
            $ComputerBiosVersion = (Get-WmiObject -Class Win32_BIOS | Select-Object -ExpandProperty SMBIOSBIOSVersion).Trim()
        }
        "*Lenovo*" {
            $ComputerManufacturer = "Lenovo"
            $ComputerModel    = (Get-WmiObject -Class Win32_ComputerSystemProduct | Select-Object -ExpandProperty Version).Trim()
            $ComputerSystemSKU= ((Get-WmiObject -Class Win32_ComputerSystem | Select-Object -ExpandProperty Model).SubString(0, 4)).Trim()
            $CurrentBIOSProperties = (Get-WmiObject -Class Win32_BIOS | Select-Object -Property *)
            $ComputerBiosVersion = "$($CurrentBIOSProperties.SystemBiosMajorVersion).$($CurrentBIOSProperties.SystemBiosMinorVersion)"
        }
    }

    # Network adapters
    $NetWorkArray = @()
    $CurrentNetAdapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }
    foreach ($CurrentNetAdapter in $CurrentNetAdapters) {
        try {
            $IPConfiguration = Get-NetIPConfiguration -InterfaceIndex $CurrentNetAdapter[0].ifIndex -ErrorAction Stop
        }
        catch { $IPConfiguration = $null }

        $ComputerNetInterfaceDescription = $CurrentNetAdapter.InterfaceDescription
        $ComputerNetProfileName          = $IPConfiguration.NetProfile.Name
        $ComputerNetIPv4Adress           = $IPConfiguration.IPv4Address.IPAddress
        $ComputerNetInterfaceAlias       = $CurrentNetAdapter.InterfaceAlias
        $ComputerNetIPv4DefaultGateway   = $IPConfiguration.IPv4DefaultGateway.NextHop
        $ComputerNetMacAddress           = $CurrentNetAdapter.MacAddress

        $tempnetwork = [PSCustomObject]@{
            NetInterfaceDescription = "$ComputerNetInterfaceDescription"
            NetProfileName          = "$ComputerNetProfileName"
            NetIPv4Adress           = "$ComputerNetIPv4Adress"
            NetInterfaceAlias       = "$ComputerNetInterfaceAlias"
            NetIPv4DefaultGateway   = "$ComputerNetIPv4DefaultGateway"
            MacAddress              = "$ComputerNetMacAddress"
        }
        $NetWorkArray += $tempnetwork
    }
    [System.Collections.ArrayList]$NetWorkArrayList = $NetWorkArray

    # Disk health
    $DiskArray = @()
    $Disks = Get-PhysicalDisk | Where-Object { $_.BusType -match "NVMe|SATA|SAS|ATAPI|RAID" }
    foreach ($Disk in ($Disks | Sort-Object DeviceID)) {
        $DiskHealth = Get-PhysicalDisk -UniqueId $($Disk.UniqueId) | Get-StorageReliabilityCounter |
            Select-Object -Property Wear, ReadErrorsTotal, ReadErrorsUncorrected, WriteErrorsTotal, WriteErrorsUncorrected, Temperature, TemperatureMax
        
        $DriveDetails   = Get-PhysicalDisk -UniqueId $($Disk.UniqueId) | Select-Object MediaType, HealthStatus
        $DriveMediaType = $DriveDetails.MediaType
        $DriveHealthState = $DriveDetails.HealthStatus
        $DiskTempDelta  = [int]$($DiskHealth.Temperature) - [int]$($DiskHealth.TemperatureMax)

        $DiskHealthState = [PSCustomObject]@{
            "Disk Number"                         = $Disk.DeviceID
            FriendlyName                          = $Disk.FriendlyName
            HealthStatus                          = $DriveHealthState
            MediaType                             = $DriveMediaType
            "Disk Wear"                           = [int]($DiskHealth.Wear)
            "Disk $($Disk.DeviceID) Read Errors"  = [int]($DiskHealth.ReadErrorsTotal)
            "Disk $($Disk.DeviceID) Temperature Delta" = $DiskTempDelta
            "Disk $($Disk.DeviceID) ReadErrorsUncorrected" = $Disk.ReadErrorsUncorrected
            "Disk $($Disk.DeviceID) ReadErrorsTotal"       = $Disk.ReadErrorsTotal
            "Disk $($Disk.DeviceID) WriteErrorsUncorrected"= $Disk.WriteErrorsUncorrected
            "Disk $($Disk.DeviceID) WriteErrorsTotal"      = $Disk.WriteErrorsTotal
        }

        $DiskArray += $DiskHealthState
    }
    [System.Collections.ArrayList]$DiskHealthArrayList = $DiskArray

    # Build Device Inventory object (1 record per device)
    $Inventory = New-Object System.Object
    $Inventory | Add-Member NoteProperty "TimeGenerated"             ((Get-Date).ToUniversalTime().ToString("o")) -Force
    $Inventory | Add-Member NoteProperty "ManagedDeviceName"         "$ManagedDeviceName" -Force
    $Inventory | Add-Member NoteProperty "AzureADDeviceID"           "$AzureADDeviceID" -Force
    $Inventory | Add-Member NoteProperty "ManagedDeviceID"           "$ManagedDeviceID" -Force
    $Inventory | Add-Member NoteProperty "ComputerName"              "$ComputerName" -Force
    $Inventory | Add-Member NoteProperty "Model"                     "$ComputerModel" -Force
    $Inventory | Add-Member NoteProperty "Manufacturer"              "$ComputerManufacturer" -Force
    $Inventory | Add-Member NoteProperty "PCSystemType"              "$ComputerPCSystemType" -Force
    $Inventory | Add-Member NoteProperty "PCSystemTypeEx"            "$ComputerPCSystemTypeEx" -Force
    $Inventory | Add-Member NoteProperty "ComputerUpTime"            "$ComputerUptime" -Force
    $Inventory | Add-Member NoteProperty "LastBoot"                  "$ComputerLastBoot" -Force
    $Inventory | Add-Member NoteProperty "InstallDate"               "$ComputerInstallDate" -Force
    $Inventory | Add-Member NoteProperty "WindowsVersion"            "$ComputerWindowsVersion" -Force
    $Inventory | Add-Member NoteProperty "DefaultAUService"          "$ComputerDefaultAUService" -Force
    $Inventory | Add-Member NoteProperty "AUMetered"                 "$ComputerAUMetered" -Force
    $Inventory | Add-Member NoteProperty "SystemSkuNumber"           "$ComputerSystemSkuNumber" -Force
    $Inventory | Add-Member NoteProperty "SerialNumber"              "$ComputerSerialNr" -Force
    $Inventory | Add-Member NoteProperty "SMBIOSUUID"                "$ComputerBiosUUID" -Force
    $Inventory | Add-Member NoteProperty "BiosVersion"               "$ComputerBiosVersion" -Force
    $Inventory | Add-Member NoteProperty "BiosDate"                  "$ComputerBiosDate" -Force
    $Inventory | Add-Member NoteProperty "SystemSKU"                 "$ComputerSystemSKU" -Force
    $Inventory | Add-Member NoteProperty "FirmwareType"              "$ComputerFirmwareType" -Force
    $Inventory | Add-Member NoteProperty "Memory"                    "$ComputerPhysicalMemory" -Force
    $Inventory | Add-Member NoteProperty "OSBuild"                   "$ComputerOSBuild" -Force
    $Inventory | Add-Member NoteProperty "OSRevision"                "$ComputerOSRevision" -Force
    $Inventory | Add-Member NoteProperty "OSName"                    "$ComputerOSName" -Force
    $Inventory | Add-Member NoteProperty "CPUManufacturer"           "$ComputerProcessorManufacturer" -Force
    $Inventory | Add-Member NoteProperty "CPUName"                   "$ComputerProcessorName" -Force
    $Inventory | Add-Member NoteProperty "CPUCores"                  "$ComputerNumberOfCores" -Force
    $Inventory | Add-Member NoteProperty "CPULogical"                "$ComputerNumberOfLogicalProcessors" -Force
    $Inventory | Add-Member NoteProperty "TPMReady"                  "$ComputerTPMReady" -Force
    $Inventory | Add-Member NoteProperty "TPMPresent"                "$ComputerTPMPresent" -Force
    $Inventory | Add-Member NoteProperty "TPMEnabled"                "$ComputerTPMEnabled" -Force
    $Inventory | Add-Member NoteProperty "TPMActived"                "$ComputerTPMActivated" -Force
    $Inventory | Add-Member NoteProperty "TPMThumbprint"             "$ComputerTPMThumbprint" -Force
    $Inventory | Add-Member NoteProperty "BitlockerCipher"           "$ComputerBitlockerCipher" -Force
    $Inventory | Add-Member NoteProperty "BitlockerVolumeStatus"     "$ComputerBitlockerStatus" -Force
    $Inventory | Add-Member NoteProperty "BitlockerProtectionStatus" "$ComputerBitlockerProtection" -Force
    $Inventory | Add-Member NoteProperty "NetworkAdapters"           $NetWorkArrayList -Force
    $Inventory | Add-Member NoteProperty "DiskHealth"                $DiskHealthArrayList -Force

    $DevicePayLoad = @($Inventory)
}
#endregion DEVICEINVENTORY


#region APPINVENTORY (rich from LA-big + batching like dcr10)
$AppPayLoad = $null
if ($CollectAppInventory) {

    # Current user SID (if logged on)
    $CurrentLoggedOnUser = (Get-CimInstance win32_computersystem).UserName
    if (-not ([string]::IsNullOrEmpty($CurrentLoggedOnUser))) {
        $AdObj = New-Object System.Security.Principal.NTAccount($CurrentLoggedOnUser)
        $strSID = $AdObj.Translate([System.Security.Principal.SecurityIdentifier])
        $UserSid = $strSID.Value
    } else {
        $UserSid = $null
    }
    
    # Get apps (system + user) using LA-big method
    $MyApps        = Get-InstalledApplications -UserSid $UserSid
    $UniqueApps    = ($MyApps | Group-Object Displayname | Where-Object { $_.Count -eq 1 }).Group
    $DuplicatedApps= ($MyApps | Group-Object Displayname | Where-Object { $_.Count -gt 1 }).Group
    $NewestDuplicateApp = ($DuplicatedApps | Group-Object DisplayName) |
        ForEach-Object { $_.Group | Sort-Object {[version]$_.DisplayVersion} -Descending | Select-Object -First 1 }
    $CleanAppList  = $UniqueApps + $NewestDuplicateApp | Sort-Object DisplayName

    $AppArray = @()
    $CurrentTime = (Get-Date).ToUniversalTime().ToString("o")

    foreach ($App in $CleanAppList) {
        $tempapp = New-Object -TypeName PSObject
        $tempapp | Add-Member NoteProperty "TimeGenerated"      $CurrentTime -Force
        $tempapp | Add-Member NoteProperty "ComputerName"       "$ComputerName" -Force
        $tempapp | Add-Member NoteProperty "ManagedDeviceName"  "$ManagedDeviceName" -Force
        $tempapp | Add-Member NoteProperty "ManagedDeviceID"    "$ManagedDeviceID" -Force
        $tempapp | Add-Member NoteProperty "WindowsVersion"     "$ComputerWindowsVersion" -Force
        $tempapp | Add-Member NoteProperty "OSBuild"            "$ComputerOSBuild" -Force

        $tempapp | Add-Member NoteProperty "AppName"            $App.DisplayName -Force
        $tempapp | Add-Member NoteProperty "AppVersion"         $App.DisplayVersion -Force
        $tempapp | Add-Member NoteProperty "AppInstallDate"     $App.InstallDate -Force -ErrorAction SilentlyContinue
        $tempapp | Add-Member NoteProperty "AppPublisher"       $App.Publisher -Force
        $tempapp | Add-Member NoteProperty "AppUninstallString" $App.UninstallString -Force
        $tempapp | Add-Member NoteProperty "AppUninstallRegPath"($App.PSPath.Split("::")[-1])
        $tempapp | Add-Member NoteProperty "AppInstallLocation" $App.InstallLocation
        $tempapp | Add-Member NoteProperty "AppInstallSource"   $App.InstallSource

        $AppArray += $tempapp
    }

    $AppPayLoad = $AppArray
}
#endregion APPINVENTORY


#region SEND TO LOG ANALYTICS WITH BATCHING
$DeviceResponseOK = $false
$AppResponseOK    = $false

$DeviceResponse = $null
$AppResponses   = @()

if ($CollectDeviceInventory -and $DevicePayLoad) {
    # Single device record – one batch
    $DeviceResponse = Send-BatchToLogAnalytics -Records $DevicePayLoad -LogType $DeviceLogName -CustomerId $CustomerId -SharedKey $SharedKey
    if ($DeviceResponse -match "200 :") { $DeviceResponseOK = $true }
}

if ($CollectAppInventory -and $AppPayLoad) {
    $totalApps = $AppPayLoad.Count
    if ($totalApps -gt 0) {
        $batchIndex = 1
        for ($i = 0; $i -lt $totalApps; $i += $AppBatchSize) {
            $endIndex = $i + $AppBatchSize - 1
            if ($endIndex -ge $totalApps) { $endIndex = $totalApps - 1 }

            $batch = $AppPayLoad[$i..$endIndex]
            $resp  = Send-BatchToLogAnalytics -Records $batch -LogType $AppLogName -CustomerId $CustomerId -SharedKey $SharedKey
            $AppResponses += "Batch $batchIndex : $resp"
            if ($resp -notmatch "200 :") { $AppResponseOK = $false } else {
                if ($batchIndex -eq 1 -and $AppResponses.Count -eq 1) { $AppResponseOK = $true }
            }
            $batchIndex++
        }
    }
}

# Report back status (Intune-friendly)
$dateString   = Get-Date -Format "dd-MM HH:mm"
$OutputMessage = "InventoryDate:$dateString "

if ($CollectDeviceInventory) {
    if ($DeviceResponseOK) {
        $OutputMessage += "DeviceInventory:OK $DeviceResponse "
    } else {
        $OutputMessage += "DeviceInventory:Fail "
    }
}

if ($CollectAppInventory) {
    if ($AppResponses.Count -eq 0) {
        $OutputMessage += "AppInventory:NoApps "
    }
    elseif ($AppResponseOK -or ($AppResponses -join "|" -match "200 :")) {
        $OutputMessage += "AppInventory:OK Batches=$($AppResponses.Count) "
    }
    else {
        $OutputMessage += "AppInventory:Fail "
    }
}

Write-Output $OutputMessage
Exit 0
#endregion script
